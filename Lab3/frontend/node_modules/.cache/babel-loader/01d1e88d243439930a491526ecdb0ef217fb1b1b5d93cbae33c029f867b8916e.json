{"ast":null,"code":"export const mockApi = (() => {\n  // in-memory data (for demo/testing only)\n  const users = {};\n  const stalls = require('./stubStalls').default; // we'll provide a simple list\n  const reviews = {};\n  return {\n    signUp: async ({\n      username,\n      email,\n      password,\n      phone,\n      diet\n    }) => {\n      if (users[username]) return {\n        success: false,\n        message: 'User exists'\n      };\n      const user = {\n        username,\n        email,\n        role: 'User',\n        points: 0,\n        phone,\n        diet,\n        lastPointsUpdate: new Date().toISOString()\n      };\n      users[username] = {\n        ...user,\n        password\n      };\n      return {\n        success: true,\n        user\n      };\n    },\n    signIn: async (username, password) => {\n      const u = users[username];\n      if (!u || u.password !== password) return {\n        success: false\n      };\n      const {\n        password: _p,\n        ...publicUser\n      } = u;\n      return {\n        success: true,\n        user: publicUser\n      };\n    },\n    getStalls: async (filters = {}) => {\n      // filters: q, tags, maxPrice, sortby, location\n      // simple filter logic\n      let list = stalls.slice();\n      if (filters.q) {\n        const q = filters.q.toLowerCase();\n        list = list.filter(s => s.name.toLowerCase().includes(q) || s.center.toLowerCase().includes(q));\n      }\n      if (filters.tags && filters.tags.length) {\n        list = list.filter(s => filters.tags.every(t => s.tags.includes(t)));\n      }\n      if (filters.maxPrice != null) {\n        list = list.filter(s => s.price <= filters.maxPrice);\n      }\n      // sort\n      if (filters.sortBy === 'price') list.sort((a, b) => a.price - b.price);\n      if (filters.sortBy === 'popularity') list.sort((a, b) => b.popularity - a.popularity);\n      // distance sorting requires location; skip complexity here\n      return {\n        success: true,\n        stalls: list\n      };\n    },\n    getStallDetails: async stallId => {\n      const s = stalls.find(x => x.id === stallId);\n      // mock crowd & queue with timestamp\n      return {\n        ...s,\n        queueEstimate: Math.floor(Math.random() * 25),\n        // minutes\n        queueTimestamp: new Date().toISOString(),\n        crowdLevel: ['Low', 'Medium', 'High'][Math.floor(Math.random() * 3)]\n      };\n    },\n    getUserPoints: async username => {\n      const u = users[username];\n      return {\n        points: (u === null || u === void 0 ? void 0 : u.points) || 0,\n        lastUpdate: u === null || u === void 0 ? void 0 : u.lastPointsUpdate\n      };\n    },\n    awardPoints: async (username, reason, qty) => {\n      const u = users[username];\n      if (!u) return {\n        success: false\n      };\n      // prevent duplicate awarding for same reason within 24 hours using a simple in-memory lastActions map\n      u.points = (u.points || 0) + qty;\n      u.lastPointsUpdate = new Date().toISOString();\n      return {\n        success: true,\n        newBalance: u.points\n      };\n    },\n    redeemReward: async (username, reward) => {\n      const u = users[username];\n      if (!u || u.points < reward.cost) return {\n        success: false,\n        message: 'Not enough points'\n      };\n      u.points -= reward.cost;\n      return {\n        success: true,\n        newBalance: u.points\n      };\n    }\n    // Reviews and admin moderation endpoints are omitted in this mock but should exist in backend\n  };\n})();","map":{"version":3,"names":["mockApi","users","stalls","require","default","reviews","signUp","username","email","password","phone","diet","success","message","user","role","points","lastPointsUpdate","Date","toISOString","signIn","u","_p","publicUser","getStalls","filters","list","slice","q","toLowerCase","filter","s","name","includes","center","tags","length","every","t","maxPrice","price","sortBy","sort","a","b","popularity","getStallDetails","stallId","find","x","id","queueEstimate","Math","floor","random","queueTimestamp","crowdLevel","getUserPoints","lastUpdate","awardPoints","reason","qty","newBalance","redeemReward","reward","cost"],"sources":["D:/Documents/GitHub/2006-SCSD-16/Lab3/frontend/src/services/mockApi.js"],"sourcesContent":["export const mockApi = (() => {\r\n  // in-memory data (for demo/testing only)\r\n  const users = {};\r\n  const stalls = require('./stubStalls').default; // we'll provide a simple list\r\n  const reviews = {};\r\n  return {\r\n    signUp: async ({ username, email, password, phone, diet }) => {\r\n      if (users[username]) return { success: false, message: 'User exists' };\r\n      const user = { username, email, role: 'User', points: 0, phone, diet, lastPointsUpdate: new Date().toISOString() };\r\n      users[username] = { ...user, password };\r\n      return { success: true, user };\r\n    },\r\n    signIn: async (username, password) => {\r\n      const u = users[username];\r\n      if (!u || u.password !== password) return { success: false };\r\n      const { password: _p, ...publicUser } = u;\r\n      return { success: true, user: publicUser };\r\n    },\r\n    getStalls: async (filters = {}) => {\r\n      // filters: q, tags, maxPrice, sortby, location\r\n      // simple filter logic\r\n      let list = stalls.slice();\r\n      if (filters.q) {\r\n        const q = filters.q.toLowerCase();\r\n        list = list.filter(s => s.name.toLowerCase().includes(q) || s.center.toLowerCase().includes(q));\r\n      }\r\n      if (filters.tags && filters.tags.length) {\r\n        list = list.filter(s => filters.tags.every(t => s.tags.includes(t)));\r\n      }\r\n      if (filters.maxPrice != null) {\r\n        list = list.filter(s => s.price <= filters.maxPrice);\r\n      }\r\n      // sort\r\n      if (filters.sortBy === 'price') list.sort((a,b)=>a.price-b.price);\r\n      if (filters.sortBy === 'popularity') list.sort((a,b)=>b.popularity-a.popularity);\r\n      // distance sorting requires location; skip complexity here\r\n      return { success: true, stalls: list };\r\n    },\r\n    getStallDetails: async (stallId) => {\r\n      const s = stalls.find(x=>x.id===stallId);\r\n      // mock crowd & queue with timestamp\r\n      return {\r\n        ...s,\r\n        queueEstimate: Math.floor(Math.random()*25), // minutes\r\n        queueTimestamp: new Date().toISOString(),\r\n        crowdLevel: ['Low','Medium','High'][Math.floor(Math.random()*3)]\r\n      };\r\n    },\r\n    getUserPoints: async (username) => {\r\n      const u = users[username];\r\n      return { points: u?.points || 0, lastUpdate: u?.lastPointsUpdate };\r\n    },\r\n    awardPoints: async (username, reason, qty) => {\r\n      const u = users[username];\r\n      if (!u) return { success: false };\r\n      // prevent duplicate awarding for same reason within 24 hours using a simple in-memory lastActions map\r\n      u.points = (u.points || 0) + qty;\r\n      u.lastPointsUpdate = new Date().toISOString();\r\n      return { success: true, newBalance: u.points };\r\n    },\r\n    redeemReward: async (username, reward) => {\r\n      const u = users[username];\r\n      if (!u || u.points < reward.cost) return { success: false, message: 'Not enough points' };\r\n      u.points -= reward.cost;\r\n      return { success: true, newBalance: u.points };\r\n    },\r\n    // Reviews and admin moderation endpoints are omitted in this mock but should exist in backend\r\n  };\r\n})();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}